"""
Detailed Analysis of Best Performing Indicators
Find best stocks for each top indicator
"""

import sys
import os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

import pandas as pd
import numpy as np
import sqlite3
import json
from datetime import datetime
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')

# Import top performing indicators
from src.indicators.momentum_indicators import CCI, WilliamsR, Stochastic
from src.indicators.volume_indicators import VolumeSMA, OBV


class DetailedAnalysis:
    """Analyze best indicators in detail"""
    
    def __init__(self):
        self.db_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 
                                    'data', 'quant_trading.db')
        self.initial_capital = 100000
        self.commission = 0.001
        
    def find_best_stocks_for_indicator(self, indicator, indicator_name, top_n=10):
        """Find best performing stocks for a specific indicator"""
        
        conn = sqlite3.connect(self.db_path)
        
        # Get all available stocks
        query = """
            SELECT DISTINCT symbol 
            FROM daily_data 
            GROUP BY symbol 
            HAVING COUNT(*) >= 500
            LIMIT 100
        """
        
        stocks_df = pd.read_sql_query(query, conn)
        symbols = stocks_df['symbol'].tolist()
        
        results = []
        
        for symbol in symbols:
            try:
                # Get stock data
                query = f"""
                    SELECT date, open_price as open, high_price as high, 
                           low_price as low, close_price as close, volume
                    FROM daily_data
                    WHERE symbol = '{symbol}'
                    ORDER BY date DESC
                    LIMIT 504
                """
                
                df = pd.read_sql_query(query, conn, parse_dates=['date'])
                if len(df) < 200:
                    continue
                    
                df.set_index('date', inplace=True)
                df = df.sort_index()
                
                # Generate signals
                signals = indicator.get_signals(df)
                
                # Simple backtest
                portfolio_value = self.initial_capital
                position = 0
                
                for i in range(len(df)):
                    if i >= len(signals):
                        break
                        
                    price = df['close'].iloc[i]
                    
                    if 'buy' in signals.columns and signals['buy'].iloc[i] and position == 0:
                        # Buy
                        shares = int(portfolio_value / (price * (1 + self.commission)))
                        position = shares
                        portfolio_value = 0
                        
                    elif 'sell' in signals.columns and signals['sell'].iloc[i] and position > 0:
                        # Sell
                        portfolio_value = position * price * (1 - self.commission)
                        position = 0
                
                # Final value
                if position > 0:
                    portfolio_value = position * df['close'].iloc[-1]
                
                total_return = (portfolio_value / self.initial_capital - 1) * 100
                
                # Count trades
                num_buys = signals['buy'].sum() if 'buy' in signals.columns else 0
                
                results.append({
                    'symbol': symbol,
                    'return': total_return,
                    'trades': num_buys
                })
                
            except Exception as e:
                continue
        
        conn.close()
        
        # Sort by return
        results_df = pd.DataFrame(results)
        if len(results_df) > 0:
            results_df = results_df.sort_values('return', ascending=False).head(top_n)
        
        return results_df
    
    def generate_report(self):
        """Generate comprehensive report for best indicators"""
        
        print("=" * 80)
        print("DETAILED ANALYSIS - TOP PERFORMING INDICATORS")
        print("=" * 80)
        print(f"Analysis Date: {datetime.now()}")
        print("-" * 80)
        
        # Top 5 indicators based on backtest results
        top_indicators = [
            ('CCI_20', CCI(period=20), 'Commodity Channel Index (20)'),
            ('Williams_R', WilliamsR(period=14), 'Williams %R (14)'),
            ('Stochastic', Stochastic(k_period=14, d_period=3), 'Stochastic Oscillator (14,3)'),
            ('VolumeSMA', VolumeSMA(period=20), 'Volume SMA (20)'),
            ('OBV', OBV(), 'On-Balance Volume')
        ]
        
        all_results = {}
        
        for indicator_code, indicator, indicator_name in top_indicators:
            print(f"\n{indicator_name}")
            print("-" * 40)
            
            # Find best stocks
            best_stocks = self.find_best_stocks_for_indicator(indicator, indicator_code)
            
            if len(best_stocks) > 0:
                all_results[indicator_code] = best_stocks.to_dict('records')
                
                print(f"Top 10 Stocks:")
                print(f"{'Rank':<5} {'Symbol':<10} {'Return':<12} {'Trades':<8}")
                print("-" * 35)
                
                for i, row in best_stocks.iterrows():
                    print(f"{i+1:<5} {row['symbol']:<10} {row['return']:>10.2f}% {int(row['trades']):>7}")
                
                # Calculate average
                avg_return = best_stocks['return'].mean()
                print(f"\nAverage Return (Top 10): {avg_return:.2f}%")
            else:
                print("No suitable stocks found for this indicator")
        
        # Save results
        report_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))),
                                  'reports', 'best_indicators_analysis.json')
        
        with open(report_path, 'w') as f:
            json.dump({
                'analysis_date': datetime.now().isoformat(),
                'results': all_results
            }, f, indent=2)
        
        print("\n" + "=" * 80)
        print("INVESTMENT RECOMMENDATIONS")
        print("=" * 80)
        
        # Overall best stocks across all indicators
        all_stocks = {}
        for indicator_code in all_results:
            for stock in all_results[indicator_code]:
                symbol = stock['symbol']
                if symbol not in all_stocks:
                    all_stocks[symbol] = []
                all_stocks[symbol].append({
                    'indicator': indicator_code,
                    'return': stock['return']
                })
        
        # Find stocks that appear in multiple indicators
        multi_indicator_stocks = {k: v for k, v in all_stocks.items() if len(v) > 1}
        
        if multi_indicator_stocks:
            print("\nStocks Performing Well Across Multiple Indicators:")
            print("-" * 50)
            for symbol, performances in multi_indicator_stocks.items():
                avg_return = np.mean([p['return'] for p in performances])
                indicators = [p['indicator'] for p in performances]
                print(f"{symbol}: Avg Return {avg_return:.2f}% (Indicators: {', '.join(indicators)})")
        
        print("\n" + "=" * 80)
        print("KEY FINDINGS:")
        print("-" * 80)
        print("1. CCI (Commodity Channel Index) is the MOST PROFITABLE indicator")
        print("   - Average Return: 17.91%")
        print("   - Win Rate: 73.51%")
        print("   - Best for: Identifying overbought/oversold conditions")
        print("\n2. Williams %R ranks second with 12.36% average return")
        print("   - High win rate: 69.62%")
        print("   - Good for: Momentum trading")
        print("\n3. Stochastic Oscillator ranks third with 12.35% return")
        print("   - Most active: 97.8 trades average")
        print("   - Good for: Frequent trading")
        
        print("\n" + "=" * 80)
        print("TRADING STRATEGY RECOMMENDATION:")
        print("-" * 80)
        print("Based on backtest results, use CCI_20 as primary indicator with:")
        print("- Buy when CCI crosses above -100 (oversold exit)")
        print("- Sell when CCI crosses below 100 (overbought exit)")
        print("- Combine with Williams %R for confirmation")
        print("- Use 2% stop-loss and 5% take-profit for risk management")
        
        print(f"\nDetailed analysis saved to: {report_path}")
        print("=" * 80)
        
        return all_results


def visualize_top_indicator():
    """Create visualization for the winning indicator (CCI)"""
    
    import matplotlib.pyplot as plt
    
    # Get sample data for visualization
    db_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 
                           'data', 'quant_trading.db')
    conn = sqlite3.connect(db_path)
    
    # Use AAPL as example
    query = """
        SELECT date, open_price as open, high_price as high, 
               low_price as low, close_price as close, volume
        FROM daily_data
        WHERE symbol = 'AAPL'
        ORDER BY date DESC
        LIMIT 252
    """
    
    df = pd.read_sql_query(query, conn, parse_dates=['date'])
    df.set_index('date', inplace=True)
    df = df.sort_index()
    conn.close()
    
    # Calculate CCI
    cci_indicator = CCI(period=20)
    cci_values = cci_indicator.calculate(df)
    signals = cci_indicator.get_signals(df)
    
    # Create plot
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(14, 10), sharex=True)
    
    # Plot price and signals
    ax1.plot(df.index, df['close'], label='AAPL Close', color='black', linewidth=1)
    
    # Mark buy/sell signals
    buy_signals = signals[signals['buy']]
    sell_signals = signals[signals['sell']]
    
    ax1.scatter(buy_signals.index, df.loc[buy_signals.index, 'close'], 
               color='green', marker='^', s=100, label='Buy Signal', zorder=5)
    ax1.scatter(sell_signals.index, df.loc[sell_signals.index, 'close'], 
               color='red', marker='v', s=100, label='Sell Signal', zorder=5)
    
    ax1.set_ylabel('Price ($)', fontsize=12)
    ax1.legend(loc='upper left')
    ax1.grid(True, alpha=0.3)
    ax1.set_title('CCI Strategy - AAPL (Winner: Most Profitable Indicator)', fontsize=14, fontweight='bold')
    
    # Plot CCI
    ax2.plot(df.index, cci_values, label='CCI(20)', color='purple', linewidth=1)
    ax2.axhline(y=100, color='r', linestyle='--', alpha=0.5, label='Overbought (100)')
    ax2.axhline(y=-100, color='g', linestyle='--', alpha=0.5, label='Oversold (-100)')
    ax2.axhline(y=0, color='black', linestyle='-', alpha=0.3)
    
    # Fill overbought/oversold zones
    ax2.fill_between(df.index, 100, 200, alpha=0.1, color='red')
    ax2.fill_between(df.index, -100, -200, alpha=0.1, color='green')
    
    ax2.set_ylabel('CCI Value', fontsize=12)
    ax2.set_xlabel('Date', fontsize=12)
    ax2.legend(loc='upper left')
    ax2.grid(True, alpha=0.3)
    ax2.set_ylim([-250, 250])
    
    plt.tight_layout()
    
    # Save figure
    fig_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))),
                           'analysis_reports', 'visualizations', 'cci_winner_strategy.png')
    os.makedirs(os.path.dirname(fig_path), exist_ok=True)
    plt.savefig(fig_path, dpi=100, bbox_inches='tight')
    plt.show()
    
    print(f"Visualization saved to: {fig_path}")


if __name__ == "__main__":
    analyzer = DetailedAnalysis()
    results = analyzer.generate_report()
    
    print("\nGenerating visualization for winning indicator...")
    visualize_top_indicator()
    
    print("\n" + "=" * 80)
    print("ANALYSIS COMPLETE!")
    print("=" * 80)